import { __awaiter } from 'tslib';
import { Injectable, ɵɵdefineInjectable, ɵɵinject, InjectionToken, Inject, NgModule } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { map, catchError, tap } from 'rxjs/operators';
import { Subject, of } from 'rxjs';
import { Router, NavigationEnd } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//@dynamic
class Alert {
}
if (false) {
    /** @type {?} */
    Alert.prototype.type;
    /** @type {?} */
    Alert.prototype.dismissSeconds;
    /** @type {?} */
    Alert.prototype.message;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//@dynamic
/**
 * @template T
 */
class ApiResponseBody {
}
if (false) {
    /** @type {?} */
    ApiResponseBody.prototype.result;
    /** @type {?} */
    ApiResponseBody.prototype.message;
    /** @type {?} */
    ApiResponseBody.prototype.redirectURL;
    /** @type {?} */
    ApiResponseBody.prototype.hasAlert;
    /** @type {?} */
    ApiResponseBody.prototype.hasValidationErrors;
    /** @type {?} */
    ApiResponseBody.prototype.alert;
    /** @type {?} */
    ApiResponseBody.prototype.validationErrors;
    /** @type {?} */
    ApiResponseBody.prototype.applicationData;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//@dynamic
/**
 * @template T
 */
class ApiResponse {
}
if (false) {
    /** @type {?} */
    ApiResponse.prototype.status;
    /** @type {?} */
    ApiResponse.prototype.body;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SHMessageUtl {
    /**
     * テンプレート文字列　形式：{0}{1}{2}
     * @param {?} text
     * @param {...?} values
     * @return {?}
     */
    stringFormat(text, ...values) {
        /** @type {?} */
        let result = text;
        values.forEach((/**
         * @param {?} value
         * @param {?} i
         * @return {?}
         */
        function (value, i) {
            result = result.split(`{${i}}`).join(value);
        }));
        return result;
    }
}
class SHMessageConfirm extends SHMessageUtl {
    /**
     * 実行確認メッセージ
     * @param {?} text
     * @return {?}
     */
    execution(text) {
        return this.stringFormat("{0}を行います。\nよろしいですか？", text);
    }
    /**
     * 終了確認メッセージ
     * @param {?} text
     * @return {?}
     */
    finalization(text) {
        return this.stringFormat("{0}を終了します。\nよろしいですか？", text);
    }
    /**
     * 登録確認メッセージ
     * @return {?}
     */
    creatingRecord() {
        return this.execution("登録");
    }
    /**
     * 修正確認メッセージ
     * @return {?}
     */
    editingRecord() {
        return this.execution("修正");
    }
    /**
     * 削除確認メッセージ
     * @return {?}
     */
    deletingRecord() {
        return this.execution("削除");
    }
    /**
     * 更新確認メッセージ
     * @return {?}
     */
    updatingRecord() {
        return this.execution("更新");
    }
    /**
     * 印刷確認メッセージ
     * @return {?}
     */
    printingOut() {
        return this.execution("印刷");
    }
    /**
     * 編集内容が失われる警告メッセージ
     * @return {?}
     */
    editingContentWillBeLost() {
        return "編集内容が失われます。\nよろしいですか？";
    }
}
class SHMessageFatal extends SHMessageUtl {
    /**
     * システムエラーメッセージ
     * @return {?}
     */
    systemErrorHasOccurred() {
        return "システムエラーが発生しました。システム管理者に連絡してください。";
    }
}
class SHMessageInfo extends SHMessageUtl {
    /**
     * 前のページに戻る場合の確認メッセージ
     * @param {?} btnName
     * @return {?}
     */
    dontUseHistoryBack(btnName) {
        return this.stringFormat("前のページに戻る場合、{0}ボタンから戻ってください。", btnName);
    }
}
class SHMessage {
    constructor() {
        /**
         * Confirm
         */
        this.confirm = new SHMessageConfirm();
        /**
         * Fatal
         */
        this.fatal = new SHMessageFatal();
        /**
         * Info
         */
        this.info = new SHMessageInfo();
    }
}
if (false) {
    /**
     * Confirm
     * @type {?}
     */
    SHMessage.prototype.confirm;
    /**
     * Fatal
     * @type {?}
     */
    SHMessage.prototype.fatal;
    /**
     * Info
     * @type {?}
     */
    SHMessage.prototype.info;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ShHttpClientConst = {
    STATUS_OK: 200,
    RELOAD: "reload",
    HTTP: "http",
    API_URL: "/api/",
    VERSION_API_URL: "/api/Version/",
    VERSION_NO: "Version-No",
    AUTHORIZATION_TOKEN: "AccessToken",
    Bearer: 'Bearer ',
    REDIRECT_PATH: 'REDIRECT_PATH',
    SH_QUERY_PARAMS: 'SH_QUERY_PARAMS'
};
/** @type {?} */
const Response = "response";
/** @type {?} */
const VersionNo = "Version-No";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VersionService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
        //versionのキャッシュ
        this.versions = [];
    }
    /**
     * versionの初期化
     * @param {...?} urls
     * @return {?}
     */
    initVersion(...urls) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!urls)
                return;
            yield Promise.all(urls.map((/**
             * @param {?} url
             * @return {?}
             */
            (url) => __awaiter(this, void 0, void 0, function* () {
                /** @type {?} */
                const result = yield this.fetchVersion(url);
                this.setVersionNo(url, result);
                return;
            }))));
        });
    }
    /**
     * urlからキーを生成
     * @private
     * @param {?} url
     * @return {?}
     */
    getKeyUrl(url) {
        if (!url)
            return "";
        return url.split(ShHttpClientConst.API_URL)[0] + ShHttpClientConst.VERSION_API_URL;
    }
    /**
     * バックエンドのversion情報を取得
     * @param {?} url
     * @return {?}
     */
    fetchVersion(url) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const s = this.splitByApiUrl(url);
            /** @type {?} */
            const token = sessionStorage.getItem(`${ShHttpClientConst.AUTHORIZATION_TOKEN}`);
            return this.http.get(s, { observe: Response, headers: { "Authorization": token ? ShHttpClientConst.Bearer + token : ShHttpClientConst.Bearer } }).toPromise()
                .then((/**
             * @param {?} response
             * @return {?}
             */
            response => {
                if (response.body.redirectURL == ShHttpClientConst.RELOAD) {
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { location.reload(); }), 100);
                }
                else if ((response.body.redirectURL || "").indexOf(ShHttpClientConst.HTTP) != -1) {
                    setTimeout((/**
                     * @return {?}
                     */
                    function () { location.href = response.body.redirectURL; }), 100);
                }
                return response.body.applicationData ? response.body.applicationData.versionNo : "";
            }));
        });
    }
    /**
     * urlをsplitした値を返す
     * @private
     * @param {?} url
     * @return {?}
     */
    splitByApiUrl(url) {
        return url.split(ShHttpClientConst.API_URL)[0] + ShHttpClientConst.VERSION_API_URL || '';
    }
    /**
     * キャッシュしているversionをURLから取得する
     * @param {?} url
     * @return {?}
     */
    getVersion(url) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const keyUrl = this.getKeyUrl(url);
            /** @type {?} */
            const projectVersion = this.versions
                .find((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                return value.keyUrl === keyUrl;
            }));
            if (!projectVersion) {
                /** @type {?} */
                const version = yield this.fetchVersion(url)
                // //キャッシュする
                ;
                // //キャッシュする
                this.setVersionNo(url, version);
                return version;
            }
            return projectVersion.version;
        });
    }
    /**
     * 受け取ったversionNoをキャッシュする
     * @param {?} url apiUrl
     * @param {?} versionNo バックエンドのversion
     * @return {?}
     */
    setVersionNo(url, versionNo) {
        /** @type {?} */
        const keyUrl = this.getKeyUrl(url);
        if (!keyUrl || !versionNo)
            return;
        /** @type {?} */
        const result = this.versions.findIndex((/**
         * @param {?} item
         * @return {?}
         */
        item => item.keyUrl == keyUrl));
        if (result != -1) {
            this.versions[result] = { keyUrl, version: versionNo };
        }
        else {
            this.versions.push({ keyUrl, version: versionNo });
        }
    }
}
VersionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
VersionService.ctorParameters = () => [
    { type: HttpClient }
];
/** @nocollapse */ VersionService.ngInjectableDef = ɵɵdefineInjectable({ factory: function VersionService_Factory() { return new VersionService(ɵɵinject(HttpClient)); }, token: VersionService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    VersionService.prototype.versions;
    /**
     * @type {?}
     * @private
     */
    VersionService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AlertHandlerService {
    /**
     * コンストラクタ
     */
    constructor() {
        this.Alert = new Alert();
        this.AlertHandlerSubject = new Subject();
        this.AlertHandlerState = this.AlertHandlerSubject.asObservable();
    }
    /**
     * アラートを追加する
     * @param {?} alertInfo
     * @return {?}
     */
    setAlert(alertInfo) {
        this.Alert = alertInfo;
        this.AlertHandlerSubject.next(this.Alert);
    }
    /**
     * アラートをクリアする
     * @return {?}
     */
    alertClear() {
        this.Alert.message = "";
        this.Alert.type = "";
        this.AlertHandlerSubject.next(this.Alert);
    }
}
AlertHandlerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AlertHandlerService.ctorParameters = () => [];
/** @nocollapse */ AlertHandlerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AlertHandlerService_Factory() { return new AlertHandlerService(); }, token: AlertHandlerService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    AlertHandlerService.prototype.Alert;
    /**
     * @type {?}
     * @private
     */
    AlertHandlerService.prototype.AlertHandlerSubject;
    /** @type {?} */
    AlertHandlerService.prototype.AlertHandlerState;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationError {
}
if (false) {
    /** @type {?} */
    ValidationError.prototype.show;
    /** @type {?} */
    ValidationError.prototype.meesages;
}
class ValidationErrorService {
    constructor() {
        this.validationError = new ValidationError();
        this.validationErrorSubject = new Subject();
        this.validationErrorState = this.validationErrorSubject.asObservable();
    }
    /**
     * @param {?} validationErrors
     * @return {?}
     */
    setValidationError(validationErrors) {
        this.validationError.show = true;
        this.validationError.meesages = validationErrors;
        this.validationErrorSubject.next(this.validationError);
    }
    /**
     * @return {?}
     */
    clearValidationError() {
        this.validationError.show = false;
        this.validationError.meesages = null;
        this.validationErrorSubject.next(this.validationError);
    }
}
ValidationErrorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ValidationErrorService.ctorParameters = () => [];
/** @nocollapse */ ValidationErrorService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ValidationErrorService_Factory() { return new ValidationErrorService(); }, token: ValidationErrorService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ValidationErrorService.prototype.validationError;
    /**
     * @type {?}
     * @private
     */
    ValidationErrorService.prototype.validationErrorSubject;
    /** @type {?} */
    ValidationErrorService.prototype.validationErrorState;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SH_BROWSER_STORAGE = new InjectionToken(`Browser Storage`, {
    providedIn: `root`,
    factory: (/**
     * @return {?}
     */
    () => localStorage)
});
/** @type {?} */
const USE_HASH = new InjectionToken('UseHash', {
    providedIn: `root`,
    factory: (/**
     * @return {?}
     */
    () => ({ useHash: true }))
});
class ShRedirectService {
    /**
     * @param {?} router
     * @param {?} storage
     * @param {?} isHash
     */
    constructor(router, storage, isHash) {
        this.router = router;
        this.storage = storage;
        this.isHash = isHash;
    }
    /**
     * @return {?}
     */
    get redirectPath() {
        return this.storage.getItem(ShHttpClientConst.REDIRECT_PATH);
    }
    /**
     * @return {?}
     */
    get queryParams() {
        /** @type {?} */
        const query = new URLSearchParams(this.storage.getItem(ShHttpClientConst.SH_QUERY_PARAMS)) || null;
        return query;
    }
    /**
     * @return {?}
     */
    setRedirectPath() {
        /** @type {?} */
        let path = '';
        /** @type {?} */
        let query = '';
        if (this.isHash.useHash) {
            /** @type {?} */
            const pathparams = location.href.split('#')[1].split('?');
            path = pathparams[0];
            query = pathparams[1] || '';
        }
        else {
            path = location.pathname;
            path = location.search;
        }
        this.storage.setItem(ShHttpClientConst.REDIRECT_PATH, path);
        this.storage.setItem(ShHttpClientConst.SH_QUERY_PARAMS, query);
    }
    /**
     * @return {?}
     */
    redirect() {
        this.router.navigate([this.storage.getItem(ShHttpClientConst.REDIRECT_PATH)]);
        this.storage.setItem(ShHttpClientConst.REDIRECT_PATH, '');
    }
}
ShRedirectService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ShRedirectService.ctorParameters = () => [
    { type: Router },
    { type: Storage, decorators: [{ type: Inject, args: [SH_BROWSER_STORAGE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [USE_HASH,] }] }
];
/** @nocollapse */ ShRedirectService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ShRedirectService_Factory() { return new ShRedirectService(ɵɵinject(Router), ɵɵinject(SH_BROWSER_STORAGE), ɵɵinject(USE_HASH)); }, token: ShRedirectService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ShRedirectService.prototype.router;
    /**
     * @type {?}
     * @private
     */
    ShRedirectService.prototype.storage;
    /**
     * @type {?}
     * @private
     */
    ShRedirectService.prototype.isHash;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShHttpClientService {
    /**
     * @param {?} http
     * @param {?} versionService
     * @param {?} alertHandlerService
     * @param {?} validationErrorService
     * @param {?} redirectService
     */
    constructor(http, versionService, alertHandlerService, validationErrorService, redirectService) {
        this.http = http;
        this.versionService = versionService;
        this.alertHandlerService = alertHandlerService;
        this.validationErrorService = validationErrorService;
        this.redirectService = redirectService;
    }
    /**
     * AccessTokenの有無を返す
     * @return {?}
     */
    get hasToken() {
        return !!sessionStorage.getItem('AccessToken');
    }
    /**
     * httpOptionを返す
     * @private
     * @param {?} versionNo
     * @return {?}
     */
    getOption(versionNo) {
        /** @type {?} */
        const token = sessionStorage.getItem(`${ShHttpClientConst.AUTHORIZATION_TOKEN}`);
        /** @type {?} */
        let headers = new HttpHeaders({ "Version-No": versionNo });
        headers = headers.set('Content-Type', 'application/json; charset=utf-8');
        /** @type {?} */
        const accessToken = token ? ShHttpClientConst.Bearer + token : ShHttpClientConst.Bearer;
        headers = headers.set('Authorization', accessToken);
        return { observe: Response, headers };
    }
    /**
     * GET
     * @private
     * @template T
     * @param {?} apiResponseBody レスポンスBody情報
     * @param {?} showValidationResult
     * @return {?} レスポンスBody内のbody句
     */
    getApiResponseBody(apiResponseBody, showValidationResult) {
        if (apiResponseBody.status != ShHttpClientConst.STATUS_OK)
            return new ApiResponseBody();
        if (apiResponseBody.body) {
            if (apiResponseBody.body.message) {
                alert(apiResponseBody.body.message);
            }
            if (apiResponseBody.body.message) {
                alert(apiResponseBody.body.message);
            }
            if (apiResponseBody.body.redirectURL == ShHttpClientConst.RELOAD) {
                setTimeout((/**
                 * @return {?}
                 */
                function () { location.reload(); }), 100);
            }
            else if ((apiResponseBody.body.redirectURL || "").indexOf(ShHttpClientConst.HTTP) != -1) {
                // useHashがtrueになっていることが前提条件です
                this.redirectService.setRedirectPath();
                setTimeout((/**
                 * @return {?}
                 */
                function () { location.href = apiResponseBody.body.redirectURL; }), 100);
            }
            if (showValidationResult) {
                //バリデーション処理
                if (apiResponseBody.body.hasValidationErrors) {
                    this.validationErrorService.setValidationError(apiResponseBody.body.validationErrors);
                }
                else {
                    this.validationErrorService.clearValidationError();
                }
            }
            if (apiResponseBody.body.alert) {
                //アラート処理
                this.alertHandlerService.setAlert(apiResponseBody.body.alert);
            }
        }
        return apiResponseBody.body;
    }
    /**
     * 認証済みかどうか
     * @private
     * @return {?}
     */
    isAuthenticate() {
        return !!sessionStorage.getItem(`${ShHttpClientConst.AUTHORIZATION_TOKEN}`);
    }
    /**
     * GET
     * @template T
     * @param {?} url ApiUrl
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    get(url, showValidationResult = true) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            let versionNo = "";
            if (this.isAuthenticate()) {
                versionNo = yield this.versionService.getVersion(url);
            }
            /** @type {?} */
            const option = this.getOption(versionNo);
            return this.http.get(this.encodeUrl(url), option).pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            response => {
                return this.getApiResponseBody(response, showValidationResult);
            })), catchError(this.handleError("get error"))).toPromise();
        });
    }
    /**
     * POST
     * @template T
     * @param {?} url ApiUrl
     * @param {?} data データ
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    post(url, data, showValidationResult = true) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const versionNo = yield this.versionService.getVersion(url);
            /** @type {?} */
            const option = this.getOption(versionNo);
            return this.http.post(url, data, option).pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            response => {
                return this.getApiResponseBody(response, showValidationResult);
            })), catchError(this.handleError("post error"))).toPromise();
        });
    }
    /**
     * PUT
     * @template T
     * @param {?} url ApiUrl
     * @param {?} data データ
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    put(url, data, showValidationResult = true) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const versionNo = yield this.versionService.getVersion(url);
            /** @type {?} */
            const option = this.getOption(versionNo);
            return this.http.put(url, data, option).pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            response => {
                return this.getApiResponseBody(response, showValidationResult);
            })), catchError(this.handleError("put error"))).toPromise();
        });
    }
    /**
     * DELETE
     * @template T
     * @param {?} url ApiUrl
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    delete(url, showValidationResult = true) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const versionNo = yield this.versionService.getVersion(url);
            /** @type {?} */
            const option = this.getOption(versionNo);
            return this.http.delete(url, option).pipe(map((/**
             * @param {?} response
             * @return {?}
             */
            response => {
                return this.getApiResponseBody(response, showValidationResult);
            })), catchError(this.handleError("delete error"))).toPromise();
        });
    }
    /**
     * エラーハンドラ
     * @private
     * @template T
     * @param {?=} operation どの処理でエラーが起きたか
     * @param {?=} result 空の配列か指定無しを返して処理を継続させる
     * @return {?}
     */
    handleError(operation = 'operation', result) {
        return (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            /** @type {?} */
            const msg = new SHMessage();
            alert(msg.fatal.systemErrorHasOccurred());
            throw error;
        });
    }
    /**
     * urlをエンコードする。インターステージ用の対応
     * @private
     * @param {?} url
     * @return {?}
     */
    encodeUrl(url) {
        if (!url)
            return;
        if (url.indexOf('?')) {
            return encodeURI(url);
        }
        return url;
    }
}
ShHttpClientService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ShHttpClientService.ctorParameters = () => [
    { type: HttpClient },
    { type: VersionService },
    { type: AlertHandlerService },
    { type: ValidationErrorService },
    { type: ShRedirectService }
];
/** @nocollapse */ ShHttpClientService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ShHttpClientService_Factory() { return new ShHttpClientService(ɵɵinject(HttpClient), ɵɵinject(VersionService), ɵɵinject(AlertHandlerService), ɵɵinject(ValidationErrorService), ɵɵinject(ShRedirectService)); }, token: ShHttpClientService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.http;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.versionService;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.alertHandlerService;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.validationErrorService;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.redirectService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthService {
    /**
     * @param {?} http
     */
    constructor(http) {
        this.http = http;
    }
    /**
     * 認証済みかの判定
     * @return {?}
     */
    isAuthenticated() {
        this.token = sessionStorage.getItem(`${ShHttpClientConst.AUTHORIZATION_TOKEN}`);
        if (this.token) {
            return of(true);
        }
        else {
            return of(false);
        }
    }
    /**
     * 認証
     * @param {?} jigCode
     * @param {?} tanCode
     * @param {?} password
     * @return {?}
     */
    login(jigCode, tanCode, password) {
        //実際はデータベースなり、ユーザー管理するサービスなりに問い合わせて戻り値を返す
        //サーバーとの通信の結果をlacalStorageへ保存（今は仮実装）
        sessionStorage.setItem(ShHttpClientConst.AUTHORIZATION_TOKEN, jigCode + tanCode + password);
        //通信の結果で分岐する
        if (true) {
            return of(true);
        }
        else {
            /**認証失敗時 */
            return of(false);
        }
    }
    /**
     * ログアウト
     * リダイレクトはガードで行う
     * @param {?} url
     * @return {?}
     */
    logout(url) {
        return this.http.get(url).then((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            sessionStorage.removeItem(ShHttpClientConst.AUTHORIZATION_TOKEN);
        }));
    }
}
AuthService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
AuthService.ctorParameters = () => [
    { type: ShHttpClientService }
];
/** @nocollapse */ AuthService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(ɵɵinject(ShHttpClientService)); }, token: AuthService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.token;
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavigationService {
    /**
     * コンストラクタ
     */
    constructor() {
        //ユーザーのブラウザバック実行状態
        this.isBackClicked = false;
    }
    /**
     * ユーザーのブラウザバック実行を保存する
     * @return {?} true/false
     */
    getBackClicked() {
        return this.isBackClicked;
    }
    /**
     * ユーザーのブラウザバック実行を保存する
     * @param {?} isBackClicked
     * @return {?}
     */
    setBackClicked(isBackClicked) {
        this.isBackClicked = isBackClicked;
    }
}
NavigationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NavigationService.ctorParameters = () => [];
/** @nocollapse */ NavigationService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NavigationService_Factory() { return new NavigationService(); }, token: NavigationService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NavigationService.prototype.isBackClicked;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoggerService {
    /**
     * @param {?} http
     * @param {?} router
     */
    constructor(http, router) {
        this.http = http;
        this.router = router;
        this.isBackButton = false;
        this.config = { url: '', useHash: true };
    }
    /**
     * logApiへリクエスト
     *
     * @private
     * @param {?} param
     * @return {?}
     */
    push(param) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.http.post(this.config.url, param);
        });
    }
    /**
     * 設定を更新
     * @template THIS
     * @this {THIS}
     * @param {?} config
     * @return {THIS}
     */
    configure(config) {
        const { url, useHash } = config;
        if (url) {
            (/** @type {?} */ (this)).config.url = url;
        }
        if (useHash !== undefined && useHash !== null) {
            (/** @type {?} */ (this)).config.useHash = useHash;
        }
        return (/** @type {?} */ (this));
    }
    /**
     * 画面遷移が発生するたびにlogging
     * @return {?}
     */
    trackingPath() {
        this.router.events.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        (event) => __awaiter(this, void 0, void 0, function* () {
            if (event instanceof NavigationEnd) {
                if (this.isBackButton) {
                    this.isBackButton = false;
                    return;
                }
                /** @type {?} */
                const path = this.config.useHash
                    ? `#${event.urlAfterRedirects}`
                    : event.urlAfterRedirects.replace('/', '');
                /** @type {?} */
                const result = yield this.push({ path });
            }
        })));
    }
    /**
     * actionlog pathは必須のため必ず送られる
     * @param {?} action
     * @return {?}
     */
    action(action) {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const path = this.config.useHash
                ? `#${this.router.url}`
                : this.router.url.replace('/', '');
            yield this.push({ path, action });
        });
    }
    /**
     *
     * @return {?}
     */
    stopLoggingPath() {
        this.isBackButton = true;
    }
}
LoggerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
LoggerService.ctorParameters = () => [
    { type: ShHttpClientService },
    { type: Router }
];
/** @nocollapse */ LoggerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function LoggerService_Factory() { return new LoggerService(ɵɵinject(ShHttpClientService), ɵɵinject(Router)); }, token: LoggerService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.isBackButton;
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.http;
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AuthGuard {
    /**
     * @param {?} authService
     * @param {?} router
     */
    constructor(authService, router) {
        this.authService = authService;
        this.router = router;
    }
    /**
     * @param {?} next
     * @param {?} state
     * @return {?}
     */
    canActivate(next, state) {
        return this.authService.isAuthenticated().pipe(tap((/**
         * @param {?} result
         * @return {?}
         */
        (result) => {
            if (!result) {
                alert("認証に失敗しました。メールアドレスとパスワードを再度確認してください。");
                return;
            }
        })));
    }
}
AuthGuard.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AuthGuard.ctorParameters = () => [
    { type: AuthService },
    { type: Router }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    AuthGuard.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    AuthGuard.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavigationGuard {
    /**
     * コンストラクタ
     * @param {?} navigationService
     */
    constructor(navigationService) {
        this.navigationService = navigationService;
    }
    /**
     * 画面遷移前処理
     * @param {?} component
     * @return {?} true/false
     */
    canDeactivate(component) {
        if (this.navigationService.getBackClicked()) {
            this.navigationService.setBackClicked(false);
            history.pushState(null, null, location.href);
            return false;
        }
        return true;
    }
}
NavigationGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NavigationGuard.ctorParameters = () => [
    { type: NavigationService }
];
/** @nocollapse */ NavigationGuard.ngInjectableDef = ɵɵdefineInjectable({ factory: function NavigationGuard_Factory() { return new NavigationGuard(ɵɵinject(NavigationService)); }, token: NavigationGuard, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NavigationGuard.prototype.navigationService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShHttpClient {
}
ShHttpClient.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    FormsModule,
                    CommonModule,
                ],
                exports: [],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Alert, AlertHandlerService, ApiResponse, ApiResponseBody, AuthGuard, AuthService, LoggerService, NavigationGuard, NavigationService, Response, SHMessage, SHMessageConfirm, SHMessageFatal, SHMessageInfo, SHMessageUtl, SH_BROWSER_STORAGE, ShHttpClient, ShHttpClientConst, ShHttpClientService, ShRedirectService, USE_HASH, ValidationErrorService, VersionNo, VersionService };
//# sourceMappingURL=sh-http-client.js.map
