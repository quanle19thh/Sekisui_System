import { __extends, __awaiter, __generator } from 'tslib';
import { Injectable, ɵɵdefineInjectable, ɵɵinject, InjectionToken, Inject, NgModule } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { map, catchError, tap } from 'rxjs/operators';
import { Subject, of } from 'rxjs';
import { Router, NavigationEnd } from '@angular/router';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//@dynamic
var  
//@dynamic
Alert = /** @class */ (function () {
    function Alert() {
    }
    return Alert;
}());
if (false) {
    /** @type {?} */
    Alert.prototype.type;
    /** @type {?} */
    Alert.prototype.dismissSeconds;
    /** @type {?} */
    Alert.prototype.message;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//@dynamic
/**
 * @template T
 */
var  
//@dynamic
/**
 * @template T
 */
ApiResponseBody = /** @class */ (function () {
    function ApiResponseBody() {
    }
    return ApiResponseBody;
}());
if (false) {
    /** @type {?} */
    ApiResponseBody.prototype.result;
    /** @type {?} */
    ApiResponseBody.prototype.message;
    /** @type {?} */
    ApiResponseBody.prototype.redirectURL;
    /** @type {?} */
    ApiResponseBody.prototype.hasAlert;
    /** @type {?} */
    ApiResponseBody.prototype.hasValidationErrors;
    /** @type {?} */
    ApiResponseBody.prototype.alert;
    /** @type {?} */
    ApiResponseBody.prototype.validationErrors;
    /** @type {?} */
    ApiResponseBody.prototype.applicationData;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//@dynamic
/**
 * @template T
 */
var  
//@dynamic
/**
 * @template T
 */
ApiResponse = /** @class */ (function () {
    function ApiResponse() {
    }
    return ApiResponse;
}());
if (false) {
    /** @type {?} */
    ApiResponse.prototype.status;
    /** @type {?} */
    ApiResponse.prototype.body;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SHMessageUtl = /** @class */ (function () {
    function SHMessageUtl() {
    }
    /**
    * テンプレート文字列　形式：{0}{1}{2}
    */
    /**
     * テンプレート文字列　形式：{0}{1}{2}
     * @param {?} text
     * @param {...?} values
     * @return {?}
     */
    SHMessageUtl.prototype.stringFormat = /**
     * テンプレート文字列　形式：{0}{1}{2}
     * @param {?} text
     * @param {...?} values
     * @return {?}
     */
    function (text) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var result = text;
        values.forEach((/**
         * @param {?} value
         * @param {?} i
         * @return {?}
         */
        function (value, i) {
            result = result.split("{" + i + "}").join(value);
        }));
        return result;
    };
    return SHMessageUtl;
}());
var SHMessageConfirm = /** @class */ (function (_super) {
    __extends(SHMessageConfirm, _super);
    function SHMessageConfirm() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
    * 実行確認メッセージ
    */
    /**
     * 実行確認メッセージ
     * @param {?} text
     * @return {?}
     */
    SHMessageConfirm.prototype.execution = /**
     * 実行確認メッセージ
     * @param {?} text
     * @return {?}
     */
    function (text) {
        return this.stringFormat("{0}を行います。\nよろしいですか？", text);
    };
    /**
    * 終了確認メッセージ
    */
    /**
     * 終了確認メッセージ
     * @param {?} text
     * @return {?}
     */
    SHMessageConfirm.prototype.finalization = /**
     * 終了確認メッセージ
     * @param {?} text
     * @return {?}
     */
    function (text) {
        return this.stringFormat("{0}を終了します。\nよろしいですか？", text);
    };
    /**
    * 登録確認メッセージ
    */
    /**
     * 登録確認メッセージ
     * @return {?}
     */
    SHMessageConfirm.prototype.creatingRecord = /**
     * 登録確認メッセージ
     * @return {?}
     */
    function () {
        return this.execution("登録");
    };
    /**
    * 修正確認メッセージ
    */
    /**
     * 修正確認メッセージ
     * @return {?}
     */
    SHMessageConfirm.prototype.editingRecord = /**
     * 修正確認メッセージ
     * @return {?}
     */
    function () {
        return this.execution("修正");
    };
    /**
    * 削除確認メッセージ
    */
    /**
     * 削除確認メッセージ
     * @return {?}
     */
    SHMessageConfirm.prototype.deletingRecord = /**
     * 削除確認メッセージ
     * @return {?}
     */
    function () {
        return this.execution("削除");
    };
    /**
    * 更新確認メッセージ
    */
    /**
     * 更新確認メッセージ
     * @return {?}
     */
    SHMessageConfirm.prototype.updatingRecord = /**
     * 更新確認メッセージ
     * @return {?}
     */
    function () {
        return this.execution("更新");
    };
    /**
    * 印刷確認メッセージ
    */
    /**
     * 印刷確認メッセージ
     * @return {?}
     */
    SHMessageConfirm.prototype.printingOut = /**
     * 印刷確認メッセージ
     * @return {?}
     */
    function () {
        return this.execution("印刷");
    };
    /**
    * 編集内容が失われる警告メッセージ
    */
    /**
     * 編集内容が失われる警告メッセージ
     * @return {?}
     */
    SHMessageConfirm.prototype.editingContentWillBeLost = /**
     * 編集内容が失われる警告メッセージ
     * @return {?}
     */
    function () {
        return "編集内容が失われます。\nよろしいですか？";
    };
    return SHMessageConfirm;
}(SHMessageUtl));
var SHMessageFatal = /** @class */ (function (_super) {
    __extends(SHMessageFatal, _super);
    function SHMessageFatal() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
    * システムエラーメッセージ
    */
    /**
     * システムエラーメッセージ
     * @return {?}
     */
    SHMessageFatal.prototype.systemErrorHasOccurred = /**
     * システムエラーメッセージ
     * @return {?}
     */
    function () {
        return "システムエラーが発生しました。システム管理者に連絡してください。";
    };
    return SHMessageFatal;
}(SHMessageUtl));
var SHMessageInfo = /** @class */ (function (_super) {
    __extends(SHMessageInfo, _super);
    function SHMessageInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
    * 前のページに戻る場合の確認メッセージ
    */
    /**
     * 前のページに戻る場合の確認メッセージ
     * @param {?} btnName
     * @return {?}
     */
    SHMessageInfo.prototype.dontUseHistoryBack = /**
     * 前のページに戻る場合の確認メッセージ
     * @param {?} btnName
     * @return {?}
     */
    function (btnName) {
        return this.stringFormat("前のページに戻る場合、{0}ボタンから戻ってください。", btnName);
    };
    return SHMessageInfo;
}(SHMessageUtl));
var SHMessage = /** @class */ (function () {
    function SHMessage() {
        /**
         * Confirm
         */
        this.confirm = new SHMessageConfirm();
        /**
         * Fatal
         */
        this.fatal = new SHMessageFatal();
        /**
         * Info
         */
        this.info = new SHMessageInfo();
    }
    return SHMessage;
}());
if (false) {
    /**
     * Confirm
     * @type {?}
     */
    SHMessage.prototype.confirm;
    /**
     * Fatal
     * @type {?}
     */
    SHMessage.prototype.fatal;
    /**
     * Info
     * @type {?}
     */
    SHMessage.prototype.info;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ShHttpClientConst = {
    STATUS_OK: 200,
    RELOAD: "reload",
    HTTP: "http",
    API_URL: "/api/",
    VERSION_API_URL: "/api/Version/",
    VERSION_NO: "Version-No",
    AUTHORIZATION_TOKEN: "AccessToken",
    Bearer: 'Bearer ',
    REDIRECT_PATH: 'REDIRECT_PATH',
    SH_QUERY_PARAMS: 'SH_QUERY_PARAMS'
};
/** @type {?} */
var Response = "response";
/** @type {?} */
var VersionNo = "Version-No";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VersionService = /** @class */ (function () {
    function VersionService(http) {
        this.http = http;
        //versionのキャッシュ
        this.versions = [];
    }
    /**
     * versionの初期化
     */
    /**
     * versionの初期化
     * @param {...?} urls
     * @return {?}
     */
    VersionService.prototype.initVersion = /**
     * versionの初期化
     * @param {...?} urls
     * @return {?}
     */
    function () {
        var urls = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            urls[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!urls)
                            return [2 /*return*/];
                        return [4 /*yield*/, Promise.all(urls.map((/**
                             * @param {?} url
                             * @return {?}
                             */
                            function (url) { return __awaiter(_this, void 0, void 0, function () {
                                var result;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.fetchVersion(url)];
                                        case 1:
                                            result = _a.sent();
                                            this.setVersionNo(url, result);
                                            return [2 /*return*/];
                                    }
                                });
                            }); })))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * urlからキーを生成
     * @param url
     */
    /**
     * urlからキーを生成
     * @private
     * @param {?} url
     * @return {?}
     */
    VersionService.prototype.getKeyUrl = /**
     * urlからキーを生成
     * @private
     * @param {?} url
     * @return {?}
     */
    function (url) {
        if (!url)
            return "";
        return url.split(ShHttpClientConst.API_URL)[0] + ShHttpClientConst.VERSION_API_URL;
    };
    /**
     * バックエンドのversion情報を取得
     */
    /**
     * バックエンドのversion情報を取得
     * @param {?} url
     * @return {?}
     */
    VersionService.prototype.fetchVersion = /**
     * バックエンドのversion情報を取得
     * @param {?} url
     * @return {?}
     */
    function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var s, token;
            return __generator(this, function (_a) {
                s = this.splitByApiUrl(url);
                token = sessionStorage.getItem("" + ShHttpClientConst.AUTHORIZATION_TOKEN);
                return [2 /*return*/, this.http.get(s, { observe: Response, headers: { "Authorization": token ? ShHttpClientConst.Bearer + token : ShHttpClientConst.Bearer } }).toPromise()
                        .then((/**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        if (response.body.redirectURL == ShHttpClientConst.RELOAD) {
                            setTimeout((/**
                             * @return {?}
                             */
                            function () { location.reload(); }), 100);
                        }
                        else if ((response.body.redirectURL || "").indexOf(ShHttpClientConst.HTTP) != -1) {
                            setTimeout((/**
                             * @return {?}
                             */
                            function () { location.href = response.body.redirectURL; }), 100);
                        }
                        return response.body.applicationData ? response.body.applicationData.versionNo : "";
                    }))];
            });
        });
    };
    /**
     * urlをsplitした値を返す
     */
    /**
     * urlをsplitした値を返す
     * @private
     * @param {?} url
     * @return {?}
     */
    VersionService.prototype.splitByApiUrl = /**
     * urlをsplitした値を返す
     * @private
     * @param {?} url
     * @return {?}
     */
    function (url) {
        return url.split(ShHttpClientConst.API_URL)[0] + ShHttpClientConst.VERSION_API_URL || '';
    };
    /**
     * キャッシュしているversionをURLから取得する
     * @param url
     */
    /**
     * キャッシュしているversionをURLから取得する
     * @param {?} url
     * @return {?}
     */
    VersionService.prototype.getVersion = /**
     * キャッシュしているversionをURLから取得する
     * @param {?} url
     * @return {?}
     */
    function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var keyUrl, projectVersion, version;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyUrl = this.getKeyUrl(url);
                        projectVersion = this.versions
                            .find((/**
                         * @param {?} value
                         * @return {?}
                         */
                        function (value) {
                            return value.keyUrl === keyUrl;
                        }));
                        if (!!projectVersion) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.fetchVersion(url)
                            // //キャッシュする
                        ];
                    case 1:
                        version = _a.sent();
                        // //キャッシュする
                        this.setVersionNo(url, version);
                        return [2 /*return*/, version];
                    case 2: return [2 /*return*/, projectVersion.version];
                }
            });
        });
    };
    /**
     * 受け取ったversionNoをキャッシュする
     * @param url apiUrl
     * @param versionNo バックエンドのversion
     */
    /**
     * 受け取ったversionNoをキャッシュする
     * @param {?} url apiUrl
     * @param {?} versionNo バックエンドのversion
     * @return {?}
     */
    VersionService.prototype.setVersionNo = /**
     * 受け取ったversionNoをキャッシュする
     * @param {?} url apiUrl
     * @param {?} versionNo バックエンドのversion
     * @return {?}
     */
    function (url, versionNo) {
        /** @type {?} */
        var keyUrl = this.getKeyUrl(url);
        if (!keyUrl || !versionNo)
            return;
        /** @type {?} */
        var result = this.versions.findIndex((/**
         * @param {?} item
         * @return {?}
         */
        function (item) { return item.keyUrl == keyUrl; }));
        if (result != -1) {
            this.versions[result] = { keyUrl: keyUrl, version: versionNo };
        }
        else {
            this.versions.push({ keyUrl: keyUrl, version: versionNo });
        }
    };
    VersionService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    VersionService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    /** @nocollapse */ VersionService.ngInjectableDef = ɵɵdefineInjectable({ factory: function VersionService_Factory() { return new VersionService(ɵɵinject(HttpClient)); }, token: VersionService, providedIn: "root" });
    return VersionService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    VersionService.prototype.versions;
    /**
     * @type {?}
     * @private
     */
    VersionService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AlertHandlerService = /** @class */ (function () {
    /**
     * コンストラクタ
     */
    function AlertHandlerService() {
        this.Alert = new Alert();
        this.AlertHandlerSubject = new Subject();
        this.AlertHandlerState = this.AlertHandlerSubject.asObservable();
    }
    /**
    * アラートを追加する
    * @param validationType 検証結果タイプ
    * @param validationMessages 検証結果メッセージ配列
    */
    /**
     * アラートを追加する
     * @param {?} alertInfo
     * @return {?}
     */
    AlertHandlerService.prototype.setAlert = /**
     * アラートを追加する
     * @param {?} alertInfo
     * @return {?}
     */
    function (alertInfo) {
        this.Alert = alertInfo;
        this.AlertHandlerSubject.next(this.Alert);
    };
    /**
     * アラートをクリアする
     */
    /**
     * アラートをクリアする
     * @return {?}
     */
    AlertHandlerService.prototype.alertClear = /**
     * アラートをクリアする
     * @return {?}
     */
    function () {
        this.Alert.message = "";
        this.Alert.type = "";
        this.AlertHandlerSubject.next(this.Alert);
    };
    AlertHandlerService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    AlertHandlerService.ctorParameters = function () { return []; };
    /** @nocollapse */ AlertHandlerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AlertHandlerService_Factory() { return new AlertHandlerService(); }, token: AlertHandlerService, providedIn: "root" });
    return AlertHandlerService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    AlertHandlerService.prototype.Alert;
    /**
     * @type {?}
     * @private
     */
    AlertHandlerService.prototype.AlertHandlerSubject;
    /** @type {?} */
    AlertHandlerService.prototype.AlertHandlerState;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValidationError = /** @class */ (function () {
    function ValidationError() {
    }
    return ValidationError;
}());
if (false) {
    /** @type {?} */
    ValidationError.prototype.show;
    /** @type {?} */
    ValidationError.prototype.meesages;
}
var ValidationErrorService = /** @class */ (function () {
    function ValidationErrorService() {
        this.validationError = new ValidationError();
        this.validationErrorSubject = new Subject();
        this.validationErrorState = this.validationErrorSubject.asObservable();
    }
    /**
     * @param {?} validationErrors
     * @return {?}
     */
    ValidationErrorService.prototype.setValidationError = /**
     * @param {?} validationErrors
     * @return {?}
     */
    function (validationErrors) {
        this.validationError.show = true;
        this.validationError.meesages = validationErrors;
        this.validationErrorSubject.next(this.validationError);
    };
    /**
     * @return {?}
     */
    ValidationErrorService.prototype.clearValidationError = /**
     * @return {?}
     */
    function () {
        this.validationError.show = false;
        this.validationError.meesages = null;
        this.validationErrorSubject.next(this.validationError);
    };
    ValidationErrorService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ValidationErrorService.ctorParameters = function () { return []; };
    /** @nocollapse */ ValidationErrorService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ValidationErrorService_Factory() { return new ValidationErrorService(); }, token: ValidationErrorService, providedIn: "root" });
    return ValidationErrorService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    ValidationErrorService.prototype.validationError;
    /**
     * @type {?}
     * @private
     */
    ValidationErrorService.prototype.validationErrorSubject;
    /** @type {?} */
    ValidationErrorService.prototype.validationErrorState;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var SH_BROWSER_STORAGE = new InjectionToken("Browser Storage", {
    providedIn: "root",
    factory: (/**
     * @return {?}
     */
    function () { return localStorage; })
});
/** @type {?} */
var USE_HASH = new InjectionToken('UseHash', {
    providedIn: "root",
    factory: (/**
     * @return {?}
     */
    function () { return ({ useHash: true }); })
});
var ShRedirectService = /** @class */ (function () {
    function ShRedirectService(router, storage, isHash) {
        this.router = router;
        this.storage = storage;
        this.isHash = isHash;
    }
    Object.defineProperty(ShRedirectService.prototype, "redirectPath", {
        get: /**
         * @return {?}
         */
        function () {
            return this.storage.getItem(ShHttpClientConst.REDIRECT_PATH);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShRedirectService.prototype, "queryParams", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var query = new URLSearchParams(this.storage.getItem(ShHttpClientConst.SH_QUERY_PARAMS)) || null;
            return query;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ShRedirectService.prototype.setRedirectPath = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var path = '';
        /** @type {?} */
        var query = '';
        if (this.isHash.useHash) {
            /** @type {?} */
            var pathparams = location.href.split('#')[1].split('?');
            path = pathparams[0];
            query = pathparams[1] || '';
        }
        else {
            path = location.pathname;
            path = location.search;
        }
        this.storage.setItem(ShHttpClientConst.REDIRECT_PATH, path);
        this.storage.setItem(ShHttpClientConst.SH_QUERY_PARAMS, query);
    };
    /**
     * @return {?}
     */
    ShRedirectService.prototype.redirect = /**
     * @return {?}
     */
    function () {
        this.router.navigate([this.storage.getItem(ShHttpClientConst.REDIRECT_PATH)]);
        this.storage.setItem(ShHttpClientConst.REDIRECT_PATH, '');
    };
    ShRedirectService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ShRedirectService.ctorParameters = function () { return [
        { type: Router },
        { type: Storage, decorators: [{ type: Inject, args: [SH_BROWSER_STORAGE,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [USE_HASH,] }] }
    ]; };
    /** @nocollapse */ ShRedirectService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ShRedirectService_Factory() { return new ShRedirectService(ɵɵinject(Router), ɵɵinject(SH_BROWSER_STORAGE), ɵɵinject(USE_HASH)); }, token: ShRedirectService, providedIn: "root" });
    return ShRedirectService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    ShRedirectService.prototype.router;
    /**
     * @type {?}
     * @private
     */
    ShRedirectService.prototype.storage;
    /**
     * @type {?}
     * @private
     */
    ShRedirectService.prototype.isHash;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShHttpClientService = /** @class */ (function () {
    function ShHttpClientService(http, versionService, alertHandlerService, validationErrorService, redirectService) {
        this.http = http;
        this.versionService = versionService;
        this.alertHandlerService = alertHandlerService;
        this.validationErrorService = validationErrorService;
        this.redirectService = redirectService;
    }
    Object.defineProperty(ShHttpClientService.prototype, "hasToken", {
        /**
         * AccessTokenの有無を返す
         */
        get: /**
         * AccessTokenの有無を返す
         * @return {?}
         */
        function () {
            return !!sessionStorage.getItem('AccessToken');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * httpOptionを返す
     * @param versionNo
     */
    /**
     * httpOptionを返す
     * @private
     * @param {?} versionNo
     * @return {?}
     */
    ShHttpClientService.prototype.getOption = /**
     * httpOptionを返す
     * @private
     * @param {?} versionNo
     * @return {?}
     */
    function (versionNo) {
        /** @type {?} */
        var token = sessionStorage.getItem("" + ShHttpClientConst.AUTHORIZATION_TOKEN);
        /** @type {?} */
        var headers = new HttpHeaders({ "Version-No": versionNo });
        headers = headers.set('Content-Type', 'application/json; charset=utf-8');
        /** @type {?} */
        var accessToken = token ? ShHttpClientConst.Bearer + token : ShHttpClientConst.Bearer;
        headers = headers.set('Authorization', accessToken);
        return { observe: Response, headers: headers };
    };
    /**
    * GET
    * @param apiResponseBody レスポンスBody情報
    * @return レスポンスBody内のbody句
    */
    /**
     * GET
     * @private
     * @template T
     * @param {?} apiResponseBody レスポンスBody情報
     * @param {?} showValidationResult
     * @return {?} レスポンスBody内のbody句
     */
    ShHttpClientService.prototype.getApiResponseBody = /**
     * GET
     * @private
     * @template T
     * @param {?} apiResponseBody レスポンスBody情報
     * @param {?} showValidationResult
     * @return {?} レスポンスBody内のbody句
     */
    function (apiResponseBody, showValidationResult) {
        if (apiResponseBody.status != ShHttpClientConst.STATUS_OK)
            return new ApiResponseBody();
        if (apiResponseBody.body) {
            if (apiResponseBody.body.message) {
                alert(apiResponseBody.body.message);
            }
            if (apiResponseBody.body.message) {
                alert(apiResponseBody.body.message);
            }
            if (apiResponseBody.body.redirectURL == ShHttpClientConst.RELOAD) {
                setTimeout((/**
                 * @return {?}
                 */
                function () { location.reload(); }), 100);
            }
            else if ((apiResponseBody.body.redirectURL || "").indexOf(ShHttpClientConst.HTTP) != -1) {
                // useHashがtrueになっていることが前提条件です
                this.redirectService.setRedirectPath();
                setTimeout((/**
                 * @return {?}
                 */
                function () { location.href = apiResponseBody.body.redirectURL; }), 100);
            }
            if (showValidationResult) {
                //バリデーション処理
                if (apiResponseBody.body.hasValidationErrors) {
                    this.validationErrorService.setValidationError(apiResponseBody.body.validationErrors);
                }
                else {
                    this.validationErrorService.clearValidationError();
                }
            }
            if (apiResponseBody.body.alert) {
                //アラート処理
                this.alertHandlerService.setAlert(apiResponseBody.body.alert);
            }
        }
        return apiResponseBody.body;
    };
    /**
     * 認証済みかどうか
     */
    /**
     * 認証済みかどうか
     * @private
     * @return {?}
     */
    ShHttpClientService.prototype.isAuthenticate = /**
     * 認証済みかどうか
     * @private
     * @return {?}
     */
    function () {
        return !!sessionStorage.getItem("" + ShHttpClientConst.AUTHORIZATION_TOKEN);
    };
    /**
    * GET
    * @param url ApiUrl
    * @return API返却結果
    */
    /**
     * GET
     * @template T
     * @param {?} url ApiUrl
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    ShHttpClientService.prototype.get = /**
     * GET
     * @template T
     * @param {?} url ApiUrl
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    function (url, showValidationResult) {
        if (showValidationResult === void 0) { showValidationResult = true; }
        return __awaiter(this, void 0, void 0, function () {
            var versionNo, option;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        versionNo = "";
                        if (!this.isAuthenticate()) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.versionService.getVersion(url)];
                    case 1:
                        versionNo = _a.sent();
                        _a.label = 2;
                    case 2:
                        option = this.getOption(versionNo);
                        return [2 /*return*/, this.http.get(this.encodeUrl(url), option).pipe(map((/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                return _this.getApiResponseBody(response, showValidationResult);
                            })), catchError(this.handleError("get error"))).toPromise()];
                }
            });
        });
    };
    /**
    * POST
    * @param url ApiUrl
    * @param data データ
    * @return API返却結果
    */
    /**
     * POST
     * @template T
     * @param {?} url ApiUrl
     * @param {?} data データ
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    ShHttpClientService.prototype.post = /**
     * POST
     * @template T
     * @param {?} url ApiUrl
     * @param {?} data データ
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    function (url, data, showValidationResult) {
        if (showValidationResult === void 0) { showValidationResult = true; }
        return __awaiter(this, void 0, void 0, function () {
            var versionNo, option;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.versionService.getVersion(url)];
                    case 1:
                        versionNo = _a.sent();
                        option = this.getOption(versionNo);
                        return [2 /*return*/, this.http.post(url, data, option).pipe(map((/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                return _this.getApiResponseBody(response, showValidationResult);
                            })), catchError(this.handleError("post error"))).toPromise()];
                }
            });
        });
    };
    /**
    * PUT
    * @param url ApiUrl
    * @param data データ
    * @return API返却結果
    */
    /**
     * PUT
     * @template T
     * @param {?} url ApiUrl
     * @param {?} data データ
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    ShHttpClientService.prototype.put = /**
     * PUT
     * @template T
     * @param {?} url ApiUrl
     * @param {?} data データ
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    function (url, data, showValidationResult) {
        if (showValidationResult === void 0) { showValidationResult = true; }
        return __awaiter(this, void 0, void 0, function () {
            var versionNo, option;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.versionService.getVersion(url)];
                    case 1:
                        versionNo = _a.sent();
                        option = this.getOption(versionNo);
                        return [2 /*return*/, this.http.put(url, data, option).pipe(map((/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                return _this.getApiResponseBody(response, showValidationResult);
                            })), catchError(this.handleError("put error"))).toPromise()];
                }
            });
        });
    };
    /**
    * DELETE
    * @param url ApiUrl
    * @return API返却結果
    */
    /**
     * DELETE
     * @template T
     * @param {?} url ApiUrl
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    ShHttpClientService.prototype.delete = /**
     * DELETE
     * @template T
     * @param {?} url ApiUrl
     * @param {?=} showValidationResult
     * @return {?} API返却結果
     */
    function (url, showValidationResult) {
        if (showValidationResult === void 0) { showValidationResult = true; }
        return __awaiter(this, void 0, void 0, function () {
            var versionNo, option;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.versionService.getVersion(url)];
                    case 1:
                        versionNo = _a.sent();
                        option = this.getOption(versionNo);
                        return [2 /*return*/, this.http.delete(url, option).pipe(map((/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                return _this.getApiResponseBody(response, showValidationResult);
                            })), catchError(this.handleError("delete error"))).toPromise()];
                }
            });
        });
    };
    /**
     * エラーハンドラ
     * @param operation どの処理でエラーが起きたか
     * @param result 空の配列か指定無しを返して処理を継続させる
     */
    /**
     * エラーハンドラ
     * @private
     * @template T
     * @param {?=} operation どの処理でエラーが起きたか
     * @param {?=} result 空の配列か指定無しを返して処理を継続させる
     * @return {?}
     */
    ShHttpClientService.prototype.handleError = /**
     * エラーハンドラ
     * @private
     * @template T
     * @param {?=} operation どの処理でエラーが起きたか
     * @param {?=} result 空の配列か指定無しを返して処理を継続させる
     * @return {?}
     */
    function (operation, result) {
        if (operation === void 0) { operation = 'operation'; }
        return (/**
         * @param {?} error
         * @return {?}
         */
        function (error) {
            /** @type {?} */
            var msg = new SHMessage();
            alert(msg.fatal.systemErrorHasOccurred());
            throw error;
        });
    };
    /**
     * urlをエンコードする。インターステージ用の対応
     * @param url
     */
    /**
     * urlをエンコードする。インターステージ用の対応
     * @private
     * @param {?} url
     * @return {?}
     */
    ShHttpClientService.prototype.encodeUrl = /**
     * urlをエンコードする。インターステージ用の対応
     * @private
     * @param {?} url
     * @return {?}
     */
    function (url) {
        if (!url)
            return;
        if (url.indexOf('?')) {
            return encodeURI(url);
        }
        return url;
    };
    ShHttpClientService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    ShHttpClientService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: VersionService },
        { type: AlertHandlerService },
        { type: ValidationErrorService },
        { type: ShRedirectService }
    ]; };
    /** @nocollapse */ ShHttpClientService.ngInjectableDef = ɵɵdefineInjectable({ factory: function ShHttpClientService_Factory() { return new ShHttpClientService(ɵɵinject(HttpClient), ɵɵinject(VersionService), ɵɵinject(AlertHandlerService), ɵɵinject(ValidationErrorService), ɵɵinject(ShRedirectService)); }, token: ShHttpClientService, providedIn: "root" });
    return ShHttpClientService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.http;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.versionService;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.alertHandlerService;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.validationErrorService;
    /**
     * @type {?}
     * @private
     */
    ShHttpClientService.prototype.redirectService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AuthService = /** @class */ (function () {
    function AuthService(http) {
        this.http = http;
    }
    /**
     * 認証済みかの判定
     */
    /**
     * 認証済みかの判定
     * @return {?}
     */
    AuthService.prototype.isAuthenticated = /**
     * 認証済みかの判定
     * @return {?}
     */
    function () {
        this.token = sessionStorage.getItem("" + ShHttpClientConst.AUTHORIZATION_TOKEN);
        if (this.token) {
            return of(true);
        }
        else {
            return of(false);
        }
    };
    /**
     * 認証
     * @param jigCode
     * @param tanCode
     * @param password
     */
    /**
     * 認証
     * @param {?} jigCode
     * @param {?} tanCode
     * @param {?} password
     * @return {?}
     */
    AuthService.prototype.login = /**
     * 認証
     * @param {?} jigCode
     * @param {?} tanCode
     * @param {?} password
     * @return {?}
     */
    function (jigCode, tanCode, password) {
        //実際はデータベースなり、ユーザー管理するサービスなりに問い合わせて戻り値を返す
        //サーバーとの通信の結果をlacalStorageへ保存（今は仮実装）
        sessionStorage.setItem(ShHttpClientConst.AUTHORIZATION_TOKEN, jigCode + tanCode + password);
        //通信の結果で分岐する
        if (true) {
            return of(true);
        }
        else {
            /**認証失敗時 */
            return of(false);
        }
    };
    /**
     * ログアウト
     * リダイレクトはガードで行う
     */
    /**
     * ログアウト
     * リダイレクトはガードで行う
     * @param {?} url
     * @return {?}
     */
    AuthService.prototype.logout = /**
     * ログアウト
     * リダイレクトはガードで行う
     * @param {?} url
     * @return {?}
     */
    function (url) {
        return this.http.get(url).then((/**
         * @param {?} _
         * @return {?}
         */
        function (_) {
            sessionStorage.removeItem(ShHttpClientConst.AUTHORIZATION_TOKEN);
        }));
    };
    AuthService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    AuthService.ctorParameters = function () { return [
        { type: ShHttpClientService }
    ]; };
    /** @nocollapse */ AuthService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(ɵɵinject(ShHttpClientService)); }, token: AuthService, providedIn: "root" });
    return AuthService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.token;
    /**
     * @type {?}
     * @private
     */
    AuthService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavigationService = /** @class */ (function () {
    /**
     * コンストラクタ
     */
    function NavigationService() {
        //ユーザーのブラウザバック実行状態
        this.isBackClicked = false;
    }
    /**
     * ユーザーのブラウザバック実行を保存する
     * @return true/false
     */
    /**
     * ユーザーのブラウザバック実行を保存する
     * @return {?} true/false
     */
    NavigationService.prototype.getBackClicked = /**
     * ユーザーのブラウザバック実行を保存する
     * @return {?} true/false
     */
    function () {
        return this.isBackClicked;
    };
    /**
     * ユーザーのブラウザバック実行を保存する
     * @param isBackClicked
     */
    /**
     * ユーザーのブラウザバック実行を保存する
     * @param {?} isBackClicked
     * @return {?}
     */
    NavigationService.prototype.setBackClicked = /**
     * ユーザーのブラウザバック実行を保存する
     * @param {?} isBackClicked
     * @return {?}
     */
    function (isBackClicked) {
        this.isBackClicked = isBackClicked;
    };
    NavigationService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NavigationService.ctorParameters = function () { return []; };
    /** @nocollapse */ NavigationService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NavigationService_Factory() { return new NavigationService(); }, token: NavigationService, providedIn: "root" });
    return NavigationService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NavigationService.prototype.isBackClicked;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var LoggerService = /** @class */ (function () {
    function LoggerService(http, router) {
        this.http = http;
        this.router = router;
        this.isBackButton = false;
        this.config = { url: '', useHash: true };
    }
    /**
     * logApiへリクエスト
     *
     */
    /**
     * logApiへリクエスト
     *
     * @private
     * @param {?} param
     * @return {?}
     */
    LoggerService.prototype.push = /**
     * logApiへリクエスト
     *
     * @private
     * @param {?} param
     * @return {?}
     */
    function (param) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.http.post(this.config.url, param)];
            });
        });
    };
    /**
     * 設定を更新
     */
    /**
     * 設定を更新
     * @template THIS
     * @this {THIS}
     * @param {?} config
     * @return {THIS}
     */
    LoggerService.prototype.configure = /**
     * 設定を更新
     * @template THIS
     * @this {THIS}
     * @param {?} config
     * @return {THIS}
     */
    function (config) {
        var url = config.url, useHash = config.useHash;
        if (url) {
            (/** @type {?} */ (this)).config.url = url;
        }
        if (useHash !== undefined && useHash !== null) {
            (/** @type {?} */ (this)).config.useHash = useHash;
        }
        return (/** @type {?} */ (this));
    };
    /**
     * 画面遷移が発生するたびにlogging
     */
    /**
     * 画面遷移が発生するたびにlogging
     * @return {?}
     */
    LoggerService.prototype.trackingPath = /**
     * 画面遷移が発生するたびにlogging
     * @return {?}
     */
    function () {
        var _this = this;
        this.router.events.subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) { return __awaiter(_this, void 0, void 0, function () {
            var path, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(event instanceof NavigationEnd)) return [3 /*break*/, 2];
                        if (this.isBackButton) {
                            this.isBackButton = false;
                            return [2 /*return*/];
                        }
                        path = this.config.useHash
                            ? "#" + event.urlAfterRedirects
                            : event.urlAfterRedirects.replace('/', '');
                        return [4 /*yield*/, this.push({ path: path })];
                    case 1:
                        result = _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); }));
    };
    /**
     * actionlog pathは必須のため必ず送られる
     */
    /**
     * actionlog pathは必須のため必ず送られる
     * @param {?} action
     * @return {?}
     */
    LoggerService.prototype.action = /**
     * actionlog pathは必須のため必ず送られる
     * @param {?} action
     * @return {?}
     */
    function (action) {
        return __awaiter(this, void 0, void 0, function () {
            var path;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = this.config.useHash
                            ? "#" + this.router.url
                            : this.router.url.replace('/', '');
                        return [4 /*yield*/, this.push({ path: path, action: action })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     *
     */
    /**
     *
     * @return {?}
     */
    LoggerService.prototype.stopLoggingPath = /**
     *
     * @return {?}
     */
    function () {
        this.isBackButton = true;
    };
    LoggerService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    LoggerService.ctorParameters = function () { return [
        { type: ShHttpClientService },
        { type: Router }
    ]; };
    /** @nocollapse */ LoggerService.ngInjectableDef = ɵɵdefineInjectable({ factory: function LoggerService_Factory() { return new LoggerService(ɵɵinject(ShHttpClientService), ɵɵinject(Router)); }, token: LoggerService, providedIn: "root" });
    return LoggerService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.isBackButton;
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.config;
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.http;
    /**
     * @type {?}
     * @private
     */
    LoggerService.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AuthGuard = /** @class */ (function () {
    function AuthGuard(authService, router) {
        this.authService = authService;
        this.router = router;
    }
    /**
     * @param {?} next
     * @param {?} state
     * @return {?}
     */
    AuthGuard.prototype.canActivate = /**
     * @param {?} next
     * @param {?} state
     * @return {?}
     */
    function (next, state) {
        return this.authService.isAuthenticated().pipe(tap((/**
         * @param {?} result
         * @return {?}
         */
        function (result) {
            if (!result) {
                alert("認証に失敗しました。メールアドレスとパスワードを再度確認してください。");
                return;
            }
        })));
    };
    AuthGuard.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AuthGuard.ctorParameters = function () { return [
        { type: AuthService },
        { type: Router }
    ]; };
    return AuthGuard;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    AuthGuard.prototype.authService;
    /**
     * @type {?}
     * @private
     */
    AuthGuard.prototype.router;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NavigationGuard = /** @class */ (function () {
    /**
    * コンストラクタ
    */
    function NavigationGuard(navigationService) {
        this.navigationService = navigationService;
    }
    /**
    * 画面遷移前処理
    * @return true/false
    */
    /**
     * 画面遷移前処理
     * @param {?} component
     * @return {?} true/false
     */
    NavigationGuard.prototype.canDeactivate = /**
     * 画面遷移前処理
     * @param {?} component
     * @return {?} true/false
     */
    function (component) {
        if (this.navigationService.getBackClicked()) {
            this.navigationService.setBackClicked(false);
            history.pushState(null, null, location.href);
            return false;
        }
        return true;
    };
    NavigationGuard.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NavigationGuard.ctorParameters = function () { return [
        { type: NavigationService }
    ]; };
    /** @nocollapse */ NavigationGuard.ngInjectableDef = ɵɵdefineInjectable({ factory: function NavigationGuard_Factory() { return new NavigationGuard(ɵɵinject(NavigationService)); }, token: NavigationGuard, providedIn: "root" });
    return NavigationGuard;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    NavigationGuard.prototype.navigationService;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ShHttpClient = /** @class */ (function () {
    function ShHttpClient() {
    }
    ShHttpClient.decorators = [
        { type: NgModule, args: [{
                    declarations: [],
                    imports: [
                        FormsModule,
                        CommonModule,
                    ],
                    exports: [],
                    providers: []
                },] }
    ];
    return ShHttpClient;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Alert, AlertHandlerService, ApiResponse, ApiResponseBody, AuthGuard, AuthService, LoggerService, NavigationGuard, NavigationService, Response, SHMessage, SHMessageConfirm, SHMessageFatal, SHMessageInfo, SHMessageUtl, SH_BROWSER_STORAGE, ShHttpClient, ShHttpClientConst, ShHttpClientService, ShRedirectService, USE_HASH, ValidationErrorService, VersionNo, VersionService };
//# sourceMappingURL=sh-http-client.js.map
